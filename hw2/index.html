<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 2 Write-Up</h1>
		<div style="text-align: center;">Names: Rachel Hu, Philip Ye</div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-skibidirizz/hw2/index.html">Homework 2 Schwaa-Money Write Up</a>

		<br>
		
		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/sp25-hw2-schwaa-money">Homework 1 Schwaa-Money GitHub Repository</a>

		<figure>
			<img src="teapot.png" alt="Teapot" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Section I: Bezier Curves and Surfaces</h2>

		<h3>Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
		<p>De Casteljau's algorithm is a recursive method used to evaluate and construct Bezier curves. It takes n points, and constructs a curve that passes through the first and last of these n points, using the intermediate ones to influence the shape of the curve.</p>
		<p>At each step of De Casteljau's algorithm, we take some n points and output n-1 new points. The algorithm iterates through the original points. On each iteration i, it uses linear interpolation with some parameter t to find a new point between the ith and (i+1)th point. The parameter t is the same for all parts of this algorithm. After going through all original n points, the algorithm has calculated (n-1) new ones. This is a single step in the recursive algorithm.</p>
		<p>We repeat this recursive step until we output just 1 point. This final point lies on the Bezier curve t, and all other points that the algorithm used and calculated help define the shape of the curve t.</p>
		<p>Here is an example of the entire De Casteljau's algorithm.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="1.1-1.png" width="500px"/>
				  <figcaption>Original Control Points.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="1.1-2.png" width="500px"/>
				  <figcaption>Step 1.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="1.1-3.png" width="500px"/>
				  <figcaption>Step 2.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="1.1-4.png" width="500px"/>
				  <figcaption>Step 3.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="1.1-5.png" width="500px"/>
				  <figcaption>Step 4.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="1.1-6.png" width="500px"/>
				  <figcaption>Step 5 with Final Bezier Curve.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<p>Here, we modified the control points to visualize a new Bezier curve. We also toggled t to illustrate how the intermediate points and steps change with parameter t.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="1.1-7.png" width="500px"/>
				  <figcaption>Shifted Control Points.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="1.1-8.png" width="500px"/>
				  <figcaption>Shifted t.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="1.1-9.png" width="500px"/>
				  <figcaption>Shifted t.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<h3>Part 2: Bezier surfaces with separable 1D de Casteljau</h3>
		<li><b>Briefly explain how de Casteljau algorithm extends to Bezier surfaces and how you implemented it in order to evaluate Bezier surfaces.</b></li>
		<br/>
		The Casteljau algorithm can extend to Bezier surfaces because Bezier surfaces can just be represented as a collection of 3D control points. In order to 
		evaluate the Bezier surface, we can generate n 3D Bezier curves -- one for each row. Once we have n of these 3D Bezier curves, we can recursively call 
		evaluateStep() on these until they converge on a single point - we will then use these n points to run our algorithm one final time to get a Bezier surface.
		<br/>
		<br/>
		<div style="text-align: center;">
			<img src="1.2-bezier-surface.png" width="500px"/>
		</div>
		

		<h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

		<h3>Part 3: Area-weighted vertex normals</h3>
		<li><b>Briefly explain how you implemented the area-weighted vertex normals.
		</b></li>
		<br/>
		<li>To implement area-weighted vertex normals, we need to calculate 1 vector normal to the face
		for every face incident to our vertex. For example, if our vertex was incident to
		6 faces, we'd need to calculate 6 normal vectors, 1 for each face, and then sum them up
		and return the unit vector of this sum.</li>
		<li>In order to traverse through all the incident faces,
		we used the algorithm described in lecture and the primer where you keep iterating through
		h->next()->twin(), and get the corresponding face from h->face(). We can compute 2 vectors along
		the face by just using 2 arbitrary face edges as these vectors, and then we compute the cross to get 
		our normal vector.
		</li>
		<br/>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="2.3-non-normalized.png" width="500px"/>
				  <figcaption>Without vertex normalization</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="2.3-normalized.png" width="500px"/>
				  <figcaption>With vertex normalization</figcaption>
				</td>
			  </tr>
			</table>
		</div>



		
		<h3>Part 4: Edge flip</h3>
		<li><b>Briefly explain how you implemented the edge flip operation and describe any interesting implementation / debugging tricks you have used.
		</b></li>
		<br/>
		Implementing edge flip was fairly straightforward - we just drew the before and after of
		our edge flip and referenced our solution with the link provided on how to correctly flip an edge. Once
		we knew our diagram was correct, we tediously reassigned a bunch of pointers, including ones that didn't change.
		One minor mistake we made along the way was assignined the outside half-edge pointers to incorrect variables,
		when we should have just set outside_halfedge->next() = outside_halfedge->next() for consistency!
		<br/>
		<br/>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="2.4-pre-flip.png" width="500px"/>
				  <figcaption>Before flip</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="2.4-post-flip.png" width="500px"/>
				  <figcaption>After flip</figcaption>
				</td>
			  </tr>
			</table>
		</div>


		<h3>Part 5: Edge split</h3>
		<li><b>Briefly explain how you implemented the edge split operation and describe any interesting implementation / debugging tricks you have used.</b></li>
		<br/>
		To be entirely honest this part was pretty much as straightforward as part 4, just a very tedious
		drawing out of the expected before and after, initializing the new items as part of the mesh,
		and then very carefully reassigning all of the pointers for every single data structure. We didn't really
		struggle nearly as much as last time, since this operation is just very detail oriented but not 
		highly complex. The only thing we had to debug was a circular Halfedge linked list which caused our code to crash,
		but we quickly identified the mistake.
		<br/>
		<br/>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="2.5-pre-split.png" width="500px"/>
				  <figcaption>Before splits</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="2.5-post-split-only.png" width="500px"/>
				  <figcaption>After splits</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<br/>
		<div style="text-align: center;">
			<img src="2.5-post-split-and-flip.png" width="500px"/>
			<figcaption>After splits and flips</figcaption>
		</div>

		
		

		<h3>Part 6: Loop subdivision for mesh upsampling</h3>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Section III: Potential Extra Credit - Art Competition: Model something Creative</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>